/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the wosm_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE wosm__scan_string(const char *str, yyscan_t scanner);
extern void wosm__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void wosm_lex_destroy(yyscan_t scanner);
extern char* wosm_get_text(yyscan_t scanner);

extern yyscan_t wosm__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  PROGRAM* program_;
  VARDECL* vardecl_;
  VAR* var_;
  ListVAR* listvar_;
  TYPE* type_;
  POINTER* pointer_;
  AST* ast_;
  ListAST* listast_;
  CONSTDECL* constdecl_;
  CONST* const_;
  ListCONST* listconst_;
  VALUE* value_;
  FUNCDECL* funcdecl_;
  FUNCTION* function_;
  ListFUNCTION* listfunction_;
  RETURN* return_;
  PARAM* param_;
  ListPARAM* listparam_;
  BLOCKPROG* blockprog_;
  CMD* cmd_;
  ListCMD* listcmd_;
  IF* if_;
  IFELSE* ifelse_;
  WHILE* while_;
  FOR* for_;
  GOTO* goto_;
  ASSIGMENT* assigment_;
  INCREMENT* increment_;
  COND* cond_;
  LOGICOP* logicop_;
  LOGICEXP* logicexp_;
  ListLOGICEXP* listlogicexp_;
  EXP* exp_;
  ARITOP* aritop_;
  ARITEXP* aritexp_;
  ListARITEXP* listaritexp_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, wosm_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANGEQ      /* != */
%token          _DAMP        /* && */
%token          _LPAREN      /* ( */
%token          _SYMB_11     /* () */
%token          _RPAREN      /* ) */
%token          _SYMB_16     /* ){ */
%token          _STAR        /* * */
%token          _PLUS        /* + */
%token          _COMMA       /* , */
%token          _MINUS       /* - */
%token          _SYMB_0      /* .wosm; */
%token          _SLASH       /* / */
%token          _SEMI        /* ; */
%token          _LT          /* < */
%token          _LDARROW     /* <= */
%token          _EQ          /* = */
%token          _DEQ         /* == */
%token          _GT          /* > */
%token          _GTEQ        /* >= */
%token          _LBRACK      /* [ */
%token          _RBRACK      /* ] */
%token          _SYMB_6      /* ]= */
%token          _KW_begin    /* begin */
%token          _KW_char     /* char */
%token          _SYMB_9      /* const{ */
%token          _KW_double   /* double */
%token          _SYMB_17     /* else{ */
%token          _KW_end      /* end */
%token          _SYMB_19     /* for( */
%token          _SYMB_10     /* function{ */
%token          _KW_goto     /* goto */
%token          _SYMB_15     /* if( */
%token          _KW_int      /* int */
%token          _KW_program  /* program */
%token          _SYMB_1      /* var{ */
%token          _KW_void     /* void */
%token          _SYMB_18     /* while( */
%token          _DBAR        /* || */
%token          _RBRACE      /* } */
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <program_> PROGRAM
%type <vardecl_> VARDECL
%type <var_> VAR
%type <listvar_> ListVAR
%type <type_> TYPE
%type <pointer_> POINTER
%type <ast_> AST
%type <listast_> ListAST
%type <constdecl_> CONSTDECL
%type <const_> CONST
%type <listconst_> ListCONST
%type <value_> VALUE
%type <funcdecl_> FUNCDECL
%type <function_> FUNCTION
%type <listfunction_> ListFUNCTION
%type <return_> RETURN
%type <param_> PARAM
%type <listparam_> ListPARAM
%type <blockprog_> BLOCKPROG
%type <cmd_> CMD
%type <listcmd_> ListCMD
%type <if_> IF
%type <ifelse_> IFELSE
%type <while_> WHILE
%type <for_> FOR
%type <goto_> GOTO
%type <assigment_> ASSIGMENT
%type <increment_> INCREMENT
%type <cond_> COND
%type <logicop_> LOGICOP
%type <logicexp_> LOGICEXP
%type <listlogicexp_> ListLOGICEXP
%type <exp_> EXP
%type <aritop_> ARITOP
%type <aritexp_> ARITEXP
%type <listaritexp_> ListARITEXP

%start PROGRAM

%%

PROGRAM : _KW_program _IDENT_ _SYMB_0 VARDECL CONSTDECL FUNCDECL BLOCKPROG { $$ = new Program($2, $4, $5, $6, $7); result->program_ = $$; }
;
VARDECL : _SYMB_1 ListVAR _RBRACE { $$ = new VDecl($2); result->vardecl_ = $$; }
  | /* empty */ { $$ = new VDeclVoid(); result->vardecl_ = $$; }
;
VAR : TYPE _IDENT_ { $$ = new Var($1, $2); result->var_ = $$; }
  | TYPE _IDENT_ _EQ VALUE { $$ = new VarAssig($1, $2, $4); result->var_ = $$; }
  | TYPE _IDENT_ _LBRACK _INTEGER_ _RBRACK { $$ = new VarV($1, $2, $4); result->var_ = $$; }
  | TYPE _IDENT_ _LBRACK _INTEGER_ _SYMB_6 VALUE { $$ = new VarAssigV($1, $2, $4, $6); result->var_ = $$; }
;
ListVAR : /* empty */ { $$ = new ListVAR(); result->listvar_ = $$; }
  | ListVAR VAR _SEMI { $1->push_back($2); $$ = $1; result->listvar_ = $$; }
;
TYPE : _KW_int { $$ = new TYPE_int(); result->type_ = $$; }
  | _KW_double { $$ = new TYPE_double(); result->type_ = $$; }
  | _KW_char { $$ = new TYPE_char(); result->type_ = $$; }
  | POINTER { $$ = new TYPEPOINTER($1); result->type_ = $$; }
;
POINTER : _KW_int ListAST { $$ = new PointerInt($2); result->pointer_ = $$; }
  | _KW_double ListAST { $$ = new PointerDouble($2); result->pointer_ = $$; }
  | _KW_char ListAST { $$ = new PointerChar($2); result->pointer_ = $$; }
;
AST : _STAR { $$ = new Ast(); result->ast_ = $$; }
;
ListAST : /* empty */ { $$ = new ListAST(); result->listast_ = $$; }
  | ListAST AST { $1->push_back($2); $$ = $1; result->listast_ = $$; }
;
CONSTDECL : _SYMB_9 ListCONST _RBRACE { $$ = new CDecl($2); result->constdecl_ = $$; }
  | /* empty */ { $$ = new CDeclVoid(); result->constdecl_ = $$; }
;
CONST : TYPE _IDENT_ _EQ VALUE { $$ = new Const($1, $2, $4); result->const_ = $$; }
;
ListCONST : /* empty */ { $$ = new ListCONST(); result->listconst_ = $$; }
  | ListCONST CONST _SEMI { $1->push_back($2); $$ = $1; result->listconst_ = $$; }
;
VALUE : _INTEGER_ { $$ = new VALUEInteger($1); result->value_ = $$; }
  | _DOUBLE_ { $$ = new VALUEDouble($1); result->value_ = $$; }
  | EXP { $$ = new VALUEEXP($1); result->value_ = $$; }
;
FUNCDECL : _SYMB_10 ListFUNCTION _RBRACE { $$ = new FDecl($2); result->funcdecl_ = $$; }
  | /* empty */ { $$ = new FDeclVoid(); result->funcdecl_ = $$; }
;
FUNCTION : RETURN _IDENT_ _SYMB_11 { $$ = new Function($1, $2); result->function_ = $$; }
  | RETURN _IDENT_ _LPAREN ListPARAM _RPAREN { std::reverse($4->begin(),$4->end()) ;$$ = new FunctionP($1, $2, $4); result->function_ = $$; }
;
ListFUNCTION : /* empty */ { $$ = new ListFUNCTION(); result->listfunction_ = $$; }
  | ListFUNCTION FUNCTION _SEMI { $1->push_back($2); $$ = $1; result->listfunction_ = $$; }
;
RETURN : _KW_int { $$ = new RETURN_int(); result->return_ = $$; }
  | _KW_double { $$ = new RETURN_double(); result->return_ = $$; }
  | _KW_char { $$ = new RETURN_char(); result->return_ = $$; }
  | _KW_void { $$ = new RETURN_void(); result->return_ = $$; }
;
PARAM : TYPE _IDENT_ { $$ = new Param($1, $2); result->param_ = $$; }
;
ListPARAM : /* empty */ { $$ = new ListPARAM(); result->listparam_ = $$; }
  | PARAM { $$ = new ListPARAM(); $$->push_back($1); result->listparam_ = $$; }
  | PARAM _COMMA ListPARAM { $3->push_back($1); $$ = $3; result->listparam_ = $$; }
;
BLOCKPROG : _KW_begin ListCMD _KW_end { $$ = new BlockProg($2); result->blockprog_ = $$; }
;
CMD : IF { $$ = new CMDIF($1); result->cmd_ = $$; }
  | IFELSE { $$ = new CMDIFELSE($1); result->cmd_ = $$; }
  | WHILE { $$ = new CMDWHILE($1); result->cmd_ = $$; }
  | FOR { $$ = new CMDFOR($1); result->cmd_ = $$; }
  | GOTO { $$ = new CMDGOTO($1); result->cmd_ = $$; }
  | ASSIGMENT { $$ = new CMDASSIGMENT($1); result->cmd_ = $$; }
;
ListCMD : /* empty */ { $$ = new ListCMD(); result->listcmd_ = $$; }
  | ListCMD CMD { $1->push_back($2); $$ = $1; result->listcmd_ = $$; }
;
IF : _SYMB_15 COND _SYMB_16 ListCMD _RBRACE { $$ = new If($2, $4); result->if_ = $$; }
;
IFELSE : IF _SYMB_17 ListCMD _RBRACE { $$ = new IfElse($1, $3); result->ifelse_ = $$; }
;
WHILE : _SYMB_18 COND _SYMB_16 ListCMD _RBRACE { $$ = new While($2, $4); result->while_ = $$; }
;
FOR : _SYMB_19 ASSIGMENT COND _SEMI INCREMENT _SYMB_16 ListCMD _RBRACE { $$ = new For($2, $3, $5, $7); result->for_ = $$; }
;
GOTO : _KW_goto _IDENT_ _SEMI { $$ = new Goto($2); result->goto_ = $$; }
;
ASSIGMENT : _IDENT_ _EQ VALUE _SEMI { $$ = new Assigment($1, $3); result->assigment_ = $$; }
  | _IDENT_ _LBRACK _INTEGER_ _SYMB_6 VALUE _SEMI { $$ = new AssigmentV($1, $3, $5); result->assigment_ = $$; }
;
INCREMENT : _IDENT_ _EQ VALUE { $$ = new Increment($1, $3); result->increment_ = $$; }
  | /* empty */ { $$ = new IncrementV(); result->increment_ = $$; }
;
COND : LOGICEXP ListLOGICEXP { std::reverse($2->begin(),$2->end()) ;$$ = new Cond($1, $2); result->cond_ = $$; }
;
LOGICOP : _LT { $$ = new LOGICOP1(); result->logicop_ = $$; }
  | _LDARROW { $$ = new LOGICOP2(); result->logicop_ = $$; }
  | _DEQ { $$ = new LOGICOP3(); result->logicop_ = $$; }
  | _BANGEQ { $$ = new LOGICOP4(); result->logicop_ = $$; }
  | _GTEQ { $$ = new LOGICOP5(); result->logicop_ = $$; }
  | _GT { $$ = new LOGICOP6(); result->logicop_ = $$; }
  | _DAMP { $$ = new LOGICOP7(); result->logicop_ = $$; }
  | _DBAR { $$ = new LOGICOP8(); result->logicop_ = $$; }
;
LOGICEXP : VALUE LOGICOP VALUE { $$ = new LogicExp($1, $2, $3); result->logicexp_ = $$; }
;
ListLOGICEXP : /* empty */ { $$ = new ListLOGICEXP(); result->listlogicexp_ = $$; }
  | LOGICEXP { $$ = new ListLOGICEXP(); $$->push_back($1); result->listlogicexp_ = $$; }
  | LOGICEXP _DAMP ListLOGICEXP { $3->push_back($1); $$ = $3; result->listlogicexp_ = $$; }
  | /* empty */ { $$ = new ListLOGICEXP(); result->listlogicexp_ = $$; }
  | LOGICEXP { $$ = new ListLOGICEXP(); $$->push_back($1); result->listlogicexp_ = $$; }
  | LOGICEXP _DBAR ListLOGICEXP { $3->push_back($1); $$ = $3; result->listlogicexp_ = $$; }
;
EXP : ARITEXP ListARITEXP { std::reverse($2->begin(),$2->end()) ;$$ = new Exp($1, $2); result->exp_ = $$; }
;
ARITOP : _PLUS { $$ = new ARITOP1(); result->aritop_ = $$; }
  | _MINUS { $$ = new ARITOP2(); result->aritop_ = $$; }
  | _STAR { $$ = new ARITOP3(); result->aritop_ = $$; }
  | _SLASH { $$ = new ARITOP4(); result->aritop_ = $$; }
;
ARITEXP : VALUE ARITOP VALUE { $$ = new AritExp($1, $2, $3); result->aritexp_ = $$; }
;
ListARITEXP : /* empty */ { $$ = new ListARITEXP(); result->listaritexp_ = $$; }
  | ARITEXP { $$ = new ListARITEXP(); $$->push_back($1); result->listaritexp_ = $$; }
  | ARITEXP _PLUS ListARITEXP { $3->push_back($1); $$ = $3; result->listaritexp_ = $$; }
  | /* empty */ { $$ = new ListARITEXP(); result->listaritexp_ = $$; }
  | ARITEXP { $$ = new ListARITEXP(); $$->push_back($1); result->listaritexp_ = $$; }
  | ARITEXP _MINUS ListARITEXP { $3->push_back($1); $$ = $3; result->listaritexp_ = $$; }
  | /* empty */ { $$ = new ListARITEXP(); result->listaritexp_ = $$; }
  | ARITEXP { $$ = new ListARITEXP(); $$->push_back($1); result->listaritexp_ = $$; }
  | ARITEXP _STAR ListARITEXP { $3->push_back($1); $$ = $3; result->listaritexp_ = $$; }
  | /* empty */ { $$ = new ListARITEXP(); result->listaritexp_ = $$; }
  | ARITEXP { $$ = new ListARITEXP(); $$->push_back($1); result->listaritexp_ = $$; }
  | ARITEXP _SLASH ListARITEXP { $3->push_back($1); $$ = $3; result->listaritexp_ = $$; }
;

%%


/* Entrypoint: parse PROGRAM* from file. */
PROGRAM* pPROGRAM(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse PROGRAM* from string. */
PROGRAM* psPROGRAM(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse VARDECL* from file. */
VARDECL* pVARDECL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vardecl_;
  }
}

/* Entrypoint: parse VARDECL* from string. */
VARDECL* psVARDECL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vardecl_;
  }
}

/* Entrypoint: parse VAR* from file. */
VAR* pVAR(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.var_;
  }
}

/* Entrypoint: parse VAR* from string. */
VAR* psVAR(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.var_;
  }
}

/* Entrypoint: parse ListVAR* from file. */
ListVAR* pListVAR(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listvar_;
  }
}

/* Entrypoint: parse ListVAR* from string. */
ListVAR* psListVAR(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listvar_;
  }
}

/* Entrypoint: parse TYPE* from file. */
TYPE* pTYPE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse TYPE* from string. */
TYPE* psTYPE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse POINTER* from file. */
POINTER* pPOINTER(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pointer_;
  }
}

/* Entrypoint: parse POINTER* from string. */
POINTER* psPOINTER(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pointer_;
  }
}

/* Entrypoint: parse AST* from file. */
AST* pAST(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ast_;
  }
}

/* Entrypoint: parse AST* from string. */
AST* psAST(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ast_;
  }
}

/* Entrypoint: parse ListAST* from file. */
ListAST* pListAST(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listast_;
  }
}

/* Entrypoint: parse ListAST* from string. */
ListAST* psListAST(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listast_;
  }
}

/* Entrypoint: parse CONSTDECL* from file. */
CONSTDECL* pCONSTDECL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constdecl_;
  }
}

/* Entrypoint: parse CONSTDECL* from string. */
CONSTDECL* psCONSTDECL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.constdecl_;
  }
}

/* Entrypoint: parse CONST* from file. */
CONST* pCONST(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.const_;
  }
}

/* Entrypoint: parse CONST* from string. */
CONST* psCONST(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.const_;
  }
}

/* Entrypoint: parse ListCONST* from file. */
ListCONST* pListCONST(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listconst_;
  }
}

/* Entrypoint: parse ListCONST* from string. */
ListCONST* psListCONST(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listconst_;
  }
}

/* Entrypoint: parse VALUE* from file. */
VALUE* pVALUE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.value_;
  }
}

/* Entrypoint: parse VALUE* from string. */
VALUE* psVALUE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.value_;
  }
}

/* Entrypoint: parse FUNCDECL* from file. */
FUNCDECL* pFUNCDECL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcdecl_;
  }
}

/* Entrypoint: parse FUNCDECL* from string. */
FUNCDECL* psFUNCDECL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcdecl_;
  }
}

/* Entrypoint: parse FUNCTION* from file. */
FUNCTION* pFUNCTION(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.function_;
  }
}

/* Entrypoint: parse FUNCTION* from string. */
FUNCTION* psFUNCTION(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.function_;
  }
}

/* Entrypoint: parse ListFUNCTION* from file. */
ListFUNCTION* pListFUNCTION(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listfunction_;
  }
}

/* Entrypoint: parse ListFUNCTION* from string. */
ListFUNCTION* psListFUNCTION(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listfunction_;
  }
}

/* Entrypoint: parse RETURN* from file. */
RETURN* pRETURN(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.return_;
  }
}

/* Entrypoint: parse RETURN* from string. */
RETURN* psRETURN(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.return_;
  }
}

/* Entrypoint: parse PARAM* from file. */
PARAM* pPARAM(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.param_;
  }
}

/* Entrypoint: parse PARAM* from string. */
PARAM* psPARAM(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.param_;
  }
}

/* Entrypoint: parse ListPARAM* from file. */
ListPARAM* pListPARAM(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparam_->begin(), result.listparam_->end());
    return result.listparam_;
  }
}

/* Entrypoint: parse ListPARAM* from string. */
ListPARAM* psListPARAM(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparam_->begin(), result.listparam_->end());
    return result.listparam_;
  }
}

/* Entrypoint: parse BLOCKPROG* from file. */
BLOCKPROG* pBLOCKPROG(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockprog_;
  }
}

/* Entrypoint: parse BLOCKPROG* from string. */
BLOCKPROG* psBLOCKPROG(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blockprog_;
  }
}

/* Entrypoint: parse CMD* from file. */
CMD* pCMD(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse CMD* from string. */
CMD* psCMD(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse ListCMD* from file. */
ListCMD* pListCMD(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listcmd_;
  }
}

/* Entrypoint: parse ListCMD* from string. */
ListCMD* psListCMD(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listcmd_;
  }
}

/* Entrypoint: parse IF* from file. */
IF* pIF(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.if_;
  }
}

/* Entrypoint: parse IF* from string. */
IF* psIF(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.if_;
  }
}

/* Entrypoint: parse IFELSE* from file. */
IFELSE* pIFELSE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ifelse_;
  }
}

/* Entrypoint: parse IFELSE* from string. */
IFELSE* psIFELSE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ifelse_;
  }
}

/* Entrypoint: parse WHILE* from file. */
WHILE* pWHILE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.while_;
  }
}

/* Entrypoint: parse WHILE* from string. */
WHILE* psWHILE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.while_;
  }
}

/* Entrypoint: parse FOR* from file. */
FOR* pFOR(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.for_;
  }
}

/* Entrypoint: parse FOR* from string. */
FOR* psFOR(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.for_;
  }
}

/* Entrypoint: parse GOTO* from file. */
GOTO* pGOTO(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.goto_;
  }
}

/* Entrypoint: parse GOTO* from string. */
GOTO* psGOTO(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.goto_;
  }
}

/* Entrypoint: parse ASSIGMENT* from file. */
ASSIGMENT* pASSIGMENT(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assigment_;
  }
}

/* Entrypoint: parse ASSIGMENT* from string. */
ASSIGMENT* psASSIGMENT(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.assigment_;
  }
}

/* Entrypoint: parse INCREMENT* from file. */
INCREMENT* pINCREMENT(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.increment_;
  }
}

/* Entrypoint: parse INCREMENT* from string. */
INCREMENT* psINCREMENT(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.increment_;
  }
}

/* Entrypoint: parse COND* from file. */
COND* pCOND(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cond_;
  }
}

/* Entrypoint: parse COND* from string. */
COND* psCOND(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cond_;
  }
}

/* Entrypoint: parse LOGICOP* from file. */
LOGICOP* pLOGICOP(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicop_;
  }
}

/* Entrypoint: parse LOGICOP* from string. */
LOGICOP* psLOGICOP(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicop_;
  }
}

/* Entrypoint: parse LOGICEXP* from file. */
LOGICEXP* pLOGICEXP(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicexp_;
  }
}

/* Entrypoint: parse LOGICEXP* from string. */
LOGICEXP* psLOGICEXP(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.logicexp_;
  }
}

/* Entrypoint: parse ListLOGICEXP* from file. */
ListLOGICEXP* pListLOGICEXP(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlogicexp_->begin(), result.listlogicexp_->end());
    return result.listlogicexp_;
  }
}

/* Entrypoint: parse ListLOGICEXP* from string. */
ListLOGICEXP* psListLOGICEXP(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlogicexp_->begin(), result.listlogicexp_->end());
    return result.listlogicexp_;
  }
}

/* Entrypoint: parse EXP* from file. */
EXP* pEXP(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse EXP* from string. */
EXP* psEXP(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse ARITOP* from file. */
ARITOP* pARITOP(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.aritop_;
  }
}

/* Entrypoint: parse ARITOP* from string. */
ARITOP* psARITOP(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.aritop_;
  }
}

/* Entrypoint: parse ARITEXP* from file. */
ARITEXP* pARITEXP(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.aritexp_;
  }
}

/* Entrypoint: parse ARITEXP* from string. */
ARITEXP* psARITEXP(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.aritexp_;
  }
}

/* Entrypoint: parse ListARITEXP* from file. */
ListARITEXP* pListARITEXP(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listaritexp_->begin(), result.listaritexp_->end());
    return result.listaritexp_;
  }
}

/* Entrypoint: parse ListARITEXP* from string. */
ListARITEXP* psListARITEXP(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = wosm__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = wosm__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  wosm__delete_buffer(buf, scanner);
  wosm_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listaritexp_->begin(), result.listaritexp_->end());
    return result.listaritexp_;
  }
}



