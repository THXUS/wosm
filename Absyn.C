/* File generated by the BNF Converter (bnfc 2.9.4). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   Program    ********************/
Program::Program(Ident p1, VARDECL *p2, CONSTDECL *p3, FUNCDECL *p4, BLOCKPROG *p5)
{
  ident_ = p1;
  vardecl_ = p2;
  constdecl_ = p3;
  funcdecl_ = p4;
  blockprog_ = p5;

}

Program::Program(const Program & other)
{
  ident_ = other.ident_;
  vardecl_ = other.vardecl_->clone();
  constdecl_ = other.constdecl_->clone();
  funcdecl_ = other.funcdecl_->clone();
  blockprog_ = other.blockprog_->clone();

}

Program &Program::operator=(const Program & other)
{
  Program tmp(other);
  swap(tmp);
  return *this;
}

void Program::swap(Program & other)
{
  std::swap(ident_, other.ident_);
  std::swap(vardecl_, other.vardecl_);
  std::swap(constdecl_, other.constdecl_);
  std::swap(funcdecl_, other.funcdecl_);
  std::swap(blockprog_, other.blockprog_);

}

Program::~Program()
{
  delete(vardecl_);
  delete(constdecl_);
  delete(funcdecl_);
  delete(blockprog_);

}

void Program::accept(Visitor *v)
{
  v->visitProgram(this);
}

Program *Program::clone() const
{
  return new Program(*this);
}



/********************   VDecl    ********************/
VDecl::VDecl(ListVAR *p1)
{
  listvar_ = p1;

}

VDecl::VDecl(const VDecl & other)
{
  listvar_ = other.listvar_->clone();

}

VDecl &VDecl::operator=(const VDecl & other)
{
  VDecl tmp(other);
  swap(tmp);
  return *this;
}

void VDecl::swap(VDecl & other)
{
  std::swap(listvar_, other.listvar_);

}

VDecl::~VDecl()
{
  delete(listvar_);

}

void VDecl::accept(Visitor *v)
{
  v->visitVDecl(this);
}

VDecl *VDecl::clone() const
{
  return new VDecl(*this);
}



/********************   VDeclVoid    ********************/
VDeclVoid::VDeclVoid()
{

}

VDeclVoid::VDeclVoid(const VDeclVoid & other)
{

}

VDeclVoid &VDeclVoid::operator=(const VDeclVoid & other)
{
  VDeclVoid tmp(other);
  swap(tmp);
  return *this;
}

void VDeclVoid::swap(VDeclVoid & other)
{

}

VDeclVoid::~VDeclVoid()
{

}

void VDeclVoid::accept(Visitor *v)
{
  v->visitVDeclVoid(this);
}

VDeclVoid *VDeclVoid::clone() const
{
  return new VDeclVoid(*this);
}



/********************   Var    ********************/
Var::Var(TYPE *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

Var::Var(const Var & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

Var &Var::operator=(const Var & other)
{
  Var tmp(other);
  swap(tmp);
  return *this;
}

void Var::swap(Var & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

Var::~Var()
{
  delete(type_);

}

void Var::accept(Visitor *v)
{
  v->visitVar(this);
}

Var *Var::clone() const
{
  return new Var(*this);
}



/********************   VarAssig    ********************/
VarAssig::VarAssig(TYPE *p1, Ident p2, VALUE *p3)
{
  type_ = p1;
  ident_ = p2;
  value_ = p3;

}

VarAssig::VarAssig(const VarAssig & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  value_ = other.value_->clone();

}

VarAssig &VarAssig::operator=(const VarAssig & other)
{
  VarAssig tmp(other);
  swap(tmp);
  return *this;
}

void VarAssig::swap(VarAssig & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(value_, other.value_);

}

VarAssig::~VarAssig()
{
  delete(type_);
  delete(value_);

}

void VarAssig::accept(Visitor *v)
{
  v->visitVarAssig(this);
}

VarAssig *VarAssig::clone() const
{
  return new VarAssig(*this);
}



/********************   VarV    ********************/
VarV::VarV(TYPE *p1, Ident p2, Integer p3)
{
  type_ = p1;
  ident_ = p2;
  integer_ = p3;

}

VarV::VarV(const VarV & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  integer_ = other.integer_;

}

VarV &VarV::operator=(const VarV & other)
{
  VarV tmp(other);
  swap(tmp);
  return *this;
}

void VarV::swap(VarV & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(integer_, other.integer_);

}

VarV::~VarV()
{
  delete(type_);

}

void VarV::accept(Visitor *v)
{
  v->visitVarV(this);
}

VarV *VarV::clone() const
{
  return new VarV(*this);
}



/********************   VarAssigV    ********************/
VarAssigV::VarAssigV(TYPE *p1, Ident p2, Integer p3, VALUE *p4)
{
  type_ = p1;
  ident_ = p2;
  integer_ = p3;
  value_ = p4;

}

VarAssigV::VarAssigV(const VarAssigV & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  integer_ = other.integer_;
  value_ = other.value_->clone();

}

VarAssigV &VarAssigV::operator=(const VarAssigV & other)
{
  VarAssigV tmp(other);
  swap(tmp);
  return *this;
}

void VarAssigV::swap(VarAssigV & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(integer_, other.integer_);
  std::swap(value_, other.value_);

}

VarAssigV::~VarAssigV()
{
  delete(type_);
  delete(value_);

}

void VarAssigV::accept(Visitor *v)
{
  v->visitVarAssigV(this);
}

VarAssigV *VarAssigV::clone() const
{
  return new VarAssigV(*this);
}



/********************   TYPE_int    ********************/
TYPE_int::TYPE_int()
{

}

TYPE_int::TYPE_int(const TYPE_int & other)
{

}

TYPE_int &TYPE_int::operator=(const TYPE_int & other)
{
  TYPE_int tmp(other);
  swap(tmp);
  return *this;
}

void TYPE_int::swap(TYPE_int & other)
{

}

TYPE_int::~TYPE_int()
{

}

void TYPE_int::accept(Visitor *v)
{
  v->visitTYPE_int(this);
}

TYPE_int *TYPE_int::clone() const
{
  return new TYPE_int(*this);
}



/********************   TYPE_double    ********************/
TYPE_double::TYPE_double()
{

}

TYPE_double::TYPE_double(const TYPE_double & other)
{

}

TYPE_double &TYPE_double::operator=(const TYPE_double & other)
{
  TYPE_double tmp(other);
  swap(tmp);
  return *this;
}

void TYPE_double::swap(TYPE_double & other)
{

}

TYPE_double::~TYPE_double()
{

}

void TYPE_double::accept(Visitor *v)
{
  v->visitTYPE_double(this);
}

TYPE_double *TYPE_double::clone() const
{
  return new TYPE_double(*this);
}



/********************   TYPE_char    ********************/
TYPE_char::TYPE_char()
{

}

TYPE_char::TYPE_char(const TYPE_char & other)
{

}

TYPE_char &TYPE_char::operator=(const TYPE_char & other)
{
  TYPE_char tmp(other);
  swap(tmp);
  return *this;
}

void TYPE_char::swap(TYPE_char & other)
{

}

TYPE_char::~TYPE_char()
{

}

void TYPE_char::accept(Visitor *v)
{
  v->visitTYPE_char(this);
}

TYPE_char *TYPE_char::clone() const
{
  return new TYPE_char(*this);
}



/********************   TYPEPOINTER    ********************/
TYPEPOINTER::TYPEPOINTER(POINTER *p1)
{
  pointer_ = p1;

}

TYPEPOINTER::TYPEPOINTER(const TYPEPOINTER & other)
{
  pointer_ = other.pointer_->clone();

}

TYPEPOINTER &TYPEPOINTER::operator=(const TYPEPOINTER & other)
{
  TYPEPOINTER tmp(other);
  swap(tmp);
  return *this;
}

void TYPEPOINTER::swap(TYPEPOINTER & other)
{
  std::swap(pointer_, other.pointer_);

}

TYPEPOINTER::~TYPEPOINTER()
{
  delete(pointer_);

}

void TYPEPOINTER::accept(Visitor *v)
{
  v->visitTYPEPOINTER(this);
}

TYPEPOINTER *TYPEPOINTER::clone() const
{
  return new TYPEPOINTER(*this);
}



/********************   PointerInt    ********************/
PointerInt::PointerInt(ListAST *p1)
{
  listast_ = p1;

}

PointerInt::PointerInt(const PointerInt & other)
{
  listast_ = other.listast_->clone();

}

PointerInt &PointerInt::operator=(const PointerInt & other)
{
  PointerInt tmp(other);
  swap(tmp);
  return *this;
}

void PointerInt::swap(PointerInt & other)
{
  std::swap(listast_, other.listast_);

}

PointerInt::~PointerInt()
{
  delete(listast_);

}

void PointerInt::accept(Visitor *v)
{
  v->visitPointerInt(this);
}

PointerInt *PointerInt::clone() const
{
  return new PointerInt(*this);
}



/********************   PointerDouble    ********************/
PointerDouble::PointerDouble(ListAST *p1)
{
  listast_ = p1;

}

PointerDouble::PointerDouble(const PointerDouble & other)
{
  listast_ = other.listast_->clone();

}

PointerDouble &PointerDouble::operator=(const PointerDouble & other)
{
  PointerDouble tmp(other);
  swap(tmp);
  return *this;
}

void PointerDouble::swap(PointerDouble & other)
{
  std::swap(listast_, other.listast_);

}

PointerDouble::~PointerDouble()
{
  delete(listast_);

}

void PointerDouble::accept(Visitor *v)
{
  v->visitPointerDouble(this);
}

PointerDouble *PointerDouble::clone() const
{
  return new PointerDouble(*this);
}



/********************   PointerChar    ********************/
PointerChar::PointerChar(ListAST *p1)
{
  listast_ = p1;

}

PointerChar::PointerChar(const PointerChar & other)
{
  listast_ = other.listast_->clone();

}

PointerChar &PointerChar::operator=(const PointerChar & other)
{
  PointerChar tmp(other);
  swap(tmp);
  return *this;
}

void PointerChar::swap(PointerChar & other)
{
  std::swap(listast_, other.listast_);

}

PointerChar::~PointerChar()
{
  delete(listast_);

}

void PointerChar::accept(Visitor *v)
{
  v->visitPointerChar(this);
}

PointerChar *PointerChar::clone() const
{
  return new PointerChar(*this);
}



/********************   Ast    ********************/
Ast::Ast()
{

}

Ast::Ast(const Ast & other)
{

}

Ast &Ast::operator=(const Ast & other)
{
  Ast tmp(other);
  swap(tmp);
  return *this;
}

void Ast::swap(Ast & other)
{

}

Ast::~Ast()
{

}

void Ast::accept(Visitor *v)
{
  v->visitAst(this);
}

Ast *Ast::clone() const
{
  return new Ast(*this);
}



/********************   CDecl    ********************/
CDecl::CDecl(ListCONST *p1)
{
  listconst_ = p1;

}

CDecl::CDecl(const CDecl & other)
{
  listconst_ = other.listconst_->clone();

}

CDecl &CDecl::operator=(const CDecl & other)
{
  CDecl tmp(other);
  swap(tmp);
  return *this;
}

void CDecl::swap(CDecl & other)
{
  std::swap(listconst_, other.listconst_);

}

CDecl::~CDecl()
{
  delete(listconst_);

}

void CDecl::accept(Visitor *v)
{
  v->visitCDecl(this);
}

CDecl *CDecl::clone() const
{
  return new CDecl(*this);
}



/********************   CDeclVoid    ********************/
CDeclVoid::CDeclVoid()
{

}

CDeclVoid::CDeclVoid(const CDeclVoid & other)
{

}

CDeclVoid &CDeclVoid::operator=(const CDeclVoid & other)
{
  CDeclVoid tmp(other);
  swap(tmp);
  return *this;
}

void CDeclVoid::swap(CDeclVoid & other)
{

}

CDeclVoid::~CDeclVoid()
{

}

void CDeclVoid::accept(Visitor *v)
{
  v->visitCDeclVoid(this);
}

CDeclVoid *CDeclVoid::clone() const
{
  return new CDeclVoid(*this);
}



/********************   Const    ********************/
Const::Const(TYPE *p1, Ident p2, VALUE *p3)
{
  type_ = p1;
  ident_ = p2;
  value_ = p3;

}

Const::Const(const Const & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  value_ = other.value_->clone();

}

Const &Const::operator=(const Const & other)
{
  Const tmp(other);
  swap(tmp);
  return *this;
}

void Const::swap(Const & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(value_, other.value_);

}

Const::~Const()
{
  delete(type_);
  delete(value_);

}

void Const::accept(Visitor *v)
{
  v->visitConst(this);
}

Const *Const::clone() const
{
  return new Const(*this);
}



/********************   VALUEInteger    ********************/
VALUEInteger::VALUEInteger(Integer p1)
{
  integer_ = p1;

}

VALUEInteger::VALUEInteger(const VALUEInteger & other)
{
  integer_ = other.integer_;

}

VALUEInteger &VALUEInteger::operator=(const VALUEInteger & other)
{
  VALUEInteger tmp(other);
  swap(tmp);
  return *this;
}

void VALUEInteger::swap(VALUEInteger & other)
{
  std::swap(integer_, other.integer_);

}

VALUEInteger::~VALUEInteger()
{

}

void VALUEInteger::accept(Visitor *v)
{
  v->visitVALUEInteger(this);
}

VALUEInteger *VALUEInteger::clone() const
{
  return new VALUEInteger(*this);
}



/********************   VALUEDouble    ********************/
VALUEDouble::VALUEDouble(Double p1)
{
  double_ = p1;

}

VALUEDouble::VALUEDouble(const VALUEDouble & other)
{
  double_ = other.double_;

}

VALUEDouble &VALUEDouble::operator=(const VALUEDouble & other)
{
  VALUEDouble tmp(other);
  swap(tmp);
  return *this;
}

void VALUEDouble::swap(VALUEDouble & other)
{
  std::swap(double_, other.double_);

}

VALUEDouble::~VALUEDouble()
{

}

void VALUEDouble::accept(Visitor *v)
{
  v->visitVALUEDouble(this);
}

VALUEDouble *VALUEDouble::clone() const
{
  return new VALUEDouble(*this);
}



/********************   VALUEEXP    ********************/
VALUEEXP::VALUEEXP(EXP *p1)
{
  exp_ = p1;

}

VALUEEXP::VALUEEXP(const VALUEEXP & other)
{
  exp_ = other.exp_->clone();

}

VALUEEXP &VALUEEXP::operator=(const VALUEEXP & other)
{
  VALUEEXP tmp(other);
  swap(tmp);
  return *this;
}

void VALUEEXP::swap(VALUEEXP & other)
{
  std::swap(exp_, other.exp_);

}

VALUEEXP::~VALUEEXP()
{
  delete(exp_);

}

void VALUEEXP::accept(Visitor *v)
{
  v->visitVALUEEXP(this);
}

VALUEEXP *VALUEEXP::clone() const
{
  return new VALUEEXP(*this);
}



/********************   FDecl    ********************/
FDecl::FDecl(ListFUNCTION *p1)
{
  listfunction_ = p1;

}

FDecl::FDecl(const FDecl & other)
{
  listfunction_ = other.listfunction_->clone();

}

FDecl &FDecl::operator=(const FDecl & other)
{
  FDecl tmp(other);
  swap(tmp);
  return *this;
}

void FDecl::swap(FDecl & other)
{
  std::swap(listfunction_, other.listfunction_);

}

FDecl::~FDecl()
{
  delete(listfunction_);

}

void FDecl::accept(Visitor *v)
{
  v->visitFDecl(this);
}

FDecl *FDecl::clone() const
{
  return new FDecl(*this);
}



/********************   FDeclVoid    ********************/
FDeclVoid::FDeclVoid()
{

}

FDeclVoid::FDeclVoid(const FDeclVoid & other)
{

}

FDeclVoid &FDeclVoid::operator=(const FDeclVoid & other)
{
  FDeclVoid tmp(other);
  swap(tmp);
  return *this;
}

void FDeclVoid::swap(FDeclVoid & other)
{

}

FDeclVoid::~FDeclVoid()
{

}

void FDeclVoid::accept(Visitor *v)
{
  v->visitFDeclVoid(this);
}

FDeclVoid *FDeclVoid::clone() const
{
  return new FDeclVoid(*this);
}



/********************   Function    ********************/
Function::Function(RETURN *p1, Ident p2)
{
  return_ = p1;
  ident_ = p2;

}

Function::Function(const Function & other)
{
  return_ = other.return_->clone();
  ident_ = other.ident_;

}

Function &Function::operator=(const Function & other)
{
  Function tmp(other);
  swap(tmp);
  return *this;
}

void Function::swap(Function & other)
{
  std::swap(return_, other.return_);
  std::swap(ident_, other.ident_);

}

Function::~Function()
{
  delete(return_);

}

void Function::accept(Visitor *v)
{
  v->visitFunction(this);
}

Function *Function::clone() const
{
  return new Function(*this);
}



/********************   FunctionP    ********************/
FunctionP::FunctionP(RETURN *p1, Ident p2, ListPARAM *p3)
{
  return_ = p1;
  ident_ = p2;
  listparam_ = p3;

}

FunctionP::FunctionP(const FunctionP & other)
{
  return_ = other.return_->clone();
  ident_ = other.ident_;
  listparam_ = other.listparam_->clone();

}

FunctionP &FunctionP::operator=(const FunctionP & other)
{
  FunctionP tmp(other);
  swap(tmp);
  return *this;
}

void FunctionP::swap(FunctionP & other)
{
  std::swap(return_, other.return_);
  std::swap(ident_, other.ident_);
  std::swap(listparam_, other.listparam_);

}

FunctionP::~FunctionP()
{
  delete(return_);
  delete(listparam_);

}

void FunctionP::accept(Visitor *v)
{
  v->visitFunctionP(this);
}

FunctionP *FunctionP::clone() const
{
  return new FunctionP(*this);
}



/********************   RETURN_int    ********************/
RETURN_int::RETURN_int()
{

}

RETURN_int::RETURN_int(const RETURN_int & other)
{

}

RETURN_int &RETURN_int::operator=(const RETURN_int & other)
{
  RETURN_int tmp(other);
  swap(tmp);
  return *this;
}

void RETURN_int::swap(RETURN_int & other)
{

}

RETURN_int::~RETURN_int()
{

}

void RETURN_int::accept(Visitor *v)
{
  v->visitRETURN_int(this);
}

RETURN_int *RETURN_int::clone() const
{
  return new RETURN_int(*this);
}



/********************   RETURN_double    ********************/
RETURN_double::RETURN_double()
{

}

RETURN_double::RETURN_double(const RETURN_double & other)
{

}

RETURN_double &RETURN_double::operator=(const RETURN_double & other)
{
  RETURN_double tmp(other);
  swap(tmp);
  return *this;
}

void RETURN_double::swap(RETURN_double & other)
{

}

RETURN_double::~RETURN_double()
{

}

void RETURN_double::accept(Visitor *v)
{
  v->visitRETURN_double(this);
}

RETURN_double *RETURN_double::clone() const
{
  return new RETURN_double(*this);
}



/********************   RETURN_char    ********************/
RETURN_char::RETURN_char()
{

}

RETURN_char::RETURN_char(const RETURN_char & other)
{

}

RETURN_char &RETURN_char::operator=(const RETURN_char & other)
{
  RETURN_char tmp(other);
  swap(tmp);
  return *this;
}

void RETURN_char::swap(RETURN_char & other)
{

}

RETURN_char::~RETURN_char()
{

}

void RETURN_char::accept(Visitor *v)
{
  v->visitRETURN_char(this);
}

RETURN_char *RETURN_char::clone() const
{
  return new RETURN_char(*this);
}



/********************   RETURN_void    ********************/
RETURN_void::RETURN_void()
{

}

RETURN_void::RETURN_void(const RETURN_void & other)
{

}

RETURN_void &RETURN_void::operator=(const RETURN_void & other)
{
  RETURN_void tmp(other);
  swap(tmp);
  return *this;
}

void RETURN_void::swap(RETURN_void & other)
{

}

RETURN_void::~RETURN_void()
{

}

void RETURN_void::accept(Visitor *v)
{
  v->visitRETURN_void(this);
}

RETURN_void *RETURN_void::clone() const
{
  return new RETURN_void(*this);
}



/********************   Param    ********************/
Param::Param(TYPE *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

Param::Param(const Param & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

Param &Param::operator=(const Param & other)
{
  Param tmp(other);
  swap(tmp);
  return *this;
}

void Param::swap(Param & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

Param::~Param()
{
  delete(type_);

}

void Param::accept(Visitor *v)
{
  v->visitParam(this);
}

Param *Param::clone() const
{
  return new Param(*this);
}



/********************   BlockProg    ********************/
BlockProg::BlockProg(ListCMD *p1)
{
  listcmd_ = p1;

}

BlockProg::BlockProg(const BlockProg & other)
{
  listcmd_ = other.listcmd_->clone();

}

BlockProg &BlockProg::operator=(const BlockProg & other)
{
  BlockProg tmp(other);
  swap(tmp);
  return *this;
}

void BlockProg::swap(BlockProg & other)
{
  std::swap(listcmd_, other.listcmd_);

}

BlockProg::~BlockProg()
{
  delete(listcmd_);

}

void BlockProg::accept(Visitor *v)
{
  v->visitBlockProg(this);
}

BlockProg *BlockProg::clone() const
{
  return new BlockProg(*this);
}



/********************   CMDIF    ********************/
CMDIF::CMDIF(IF *p1)
{
  if_ = p1;

}

CMDIF::CMDIF(const CMDIF & other)
{
  if_ = other.if_->clone();

}

CMDIF &CMDIF::operator=(const CMDIF & other)
{
  CMDIF tmp(other);
  swap(tmp);
  return *this;
}

void CMDIF::swap(CMDIF & other)
{
  std::swap(if_, other.if_);

}

CMDIF::~CMDIF()
{
  delete(if_);

}

void CMDIF::accept(Visitor *v)
{
  v->visitCMDIF(this);
}

CMDIF *CMDIF::clone() const
{
  return new CMDIF(*this);
}



/********************   CMDIFELSE    ********************/
CMDIFELSE::CMDIFELSE(IFELSE *p1)
{
  ifelse_ = p1;

}

CMDIFELSE::CMDIFELSE(const CMDIFELSE & other)
{
  ifelse_ = other.ifelse_->clone();

}

CMDIFELSE &CMDIFELSE::operator=(const CMDIFELSE & other)
{
  CMDIFELSE tmp(other);
  swap(tmp);
  return *this;
}

void CMDIFELSE::swap(CMDIFELSE & other)
{
  std::swap(ifelse_, other.ifelse_);

}

CMDIFELSE::~CMDIFELSE()
{
  delete(ifelse_);

}

void CMDIFELSE::accept(Visitor *v)
{
  v->visitCMDIFELSE(this);
}

CMDIFELSE *CMDIFELSE::clone() const
{
  return new CMDIFELSE(*this);
}



/********************   CMDWHILE    ********************/
CMDWHILE::CMDWHILE(WHILE *p1)
{
  while_ = p1;

}

CMDWHILE::CMDWHILE(const CMDWHILE & other)
{
  while_ = other.while_->clone();

}

CMDWHILE &CMDWHILE::operator=(const CMDWHILE & other)
{
  CMDWHILE tmp(other);
  swap(tmp);
  return *this;
}

void CMDWHILE::swap(CMDWHILE & other)
{
  std::swap(while_, other.while_);

}

CMDWHILE::~CMDWHILE()
{
  delete(while_);

}

void CMDWHILE::accept(Visitor *v)
{
  v->visitCMDWHILE(this);
}

CMDWHILE *CMDWHILE::clone() const
{
  return new CMDWHILE(*this);
}



/********************   CMDFOR    ********************/
CMDFOR::CMDFOR(FOR *p1)
{
  for_ = p1;

}

CMDFOR::CMDFOR(const CMDFOR & other)
{
  for_ = other.for_->clone();

}

CMDFOR &CMDFOR::operator=(const CMDFOR & other)
{
  CMDFOR tmp(other);
  swap(tmp);
  return *this;
}

void CMDFOR::swap(CMDFOR & other)
{
  std::swap(for_, other.for_);

}

CMDFOR::~CMDFOR()
{
  delete(for_);

}

void CMDFOR::accept(Visitor *v)
{
  v->visitCMDFOR(this);
}

CMDFOR *CMDFOR::clone() const
{
  return new CMDFOR(*this);
}



/********************   CMDGOTO    ********************/
CMDGOTO::CMDGOTO(GOTO *p1)
{
  goto_ = p1;

}

CMDGOTO::CMDGOTO(const CMDGOTO & other)
{
  goto_ = other.goto_->clone();

}

CMDGOTO &CMDGOTO::operator=(const CMDGOTO & other)
{
  CMDGOTO tmp(other);
  swap(tmp);
  return *this;
}

void CMDGOTO::swap(CMDGOTO & other)
{
  std::swap(goto_, other.goto_);

}

CMDGOTO::~CMDGOTO()
{
  delete(goto_);

}

void CMDGOTO::accept(Visitor *v)
{
  v->visitCMDGOTO(this);
}

CMDGOTO *CMDGOTO::clone() const
{
  return new CMDGOTO(*this);
}



/********************   CMDASSIGMENT    ********************/
CMDASSIGMENT::CMDASSIGMENT(ASSIGMENT *p1)
{
  assigment_ = p1;

}

CMDASSIGMENT::CMDASSIGMENT(const CMDASSIGMENT & other)
{
  assigment_ = other.assigment_->clone();

}

CMDASSIGMENT &CMDASSIGMENT::operator=(const CMDASSIGMENT & other)
{
  CMDASSIGMENT tmp(other);
  swap(tmp);
  return *this;
}

void CMDASSIGMENT::swap(CMDASSIGMENT & other)
{
  std::swap(assigment_, other.assigment_);

}

CMDASSIGMENT::~CMDASSIGMENT()
{
  delete(assigment_);

}

void CMDASSIGMENT::accept(Visitor *v)
{
  v->visitCMDASSIGMENT(this);
}

CMDASSIGMENT *CMDASSIGMENT::clone() const
{
  return new CMDASSIGMENT(*this);
}



/********************   If    ********************/
If::If(COND *p1, ListCMD *p2)
{
  cond_ = p1;
  listcmd_ = p2;

}

If::If(const If & other)
{
  cond_ = other.cond_->clone();
  listcmd_ = other.listcmd_->clone();

}

If &If::operator=(const If & other)
{
  If tmp(other);
  swap(tmp);
  return *this;
}

void If::swap(If & other)
{
  std::swap(cond_, other.cond_);
  std::swap(listcmd_, other.listcmd_);

}

If::~If()
{
  delete(cond_);
  delete(listcmd_);

}

void If::accept(Visitor *v)
{
  v->visitIf(this);
}

If *If::clone() const
{
  return new If(*this);
}



/********************   IfElse    ********************/
IfElse::IfElse(IF *p1, ListCMD *p2)
{
  if_ = p1;
  listcmd_ = p2;

}

IfElse::IfElse(const IfElse & other)
{
  if_ = other.if_->clone();
  listcmd_ = other.listcmd_->clone();

}

IfElse &IfElse::operator=(const IfElse & other)
{
  IfElse tmp(other);
  swap(tmp);
  return *this;
}

void IfElse::swap(IfElse & other)
{
  std::swap(if_, other.if_);
  std::swap(listcmd_, other.listcmd_);

}

IfElse::~IfElse()
{
  delete(if_);
  delete(listcmd_);

}

void IfElse::accept(Visitor *v)
{
  v->visitIfElse(this);
}

IfElse *IfElse::clone() const
{
  return new IfElse(*this);
}



/********************   While    ********************/
While::While(COND *p1, ListCMD *p2)
{
  cond_ = p1;
  listcmd_ = p2;

}

While::While(const While & other)
{
  cond_ = other.cond_->clone();
  listcmd_ = other.listcmd_->clone();

}

While &While::operator=(const While & other)
{
  While tmp(other);
  swap(tmp);
  return *this;
}

void While::swap(While & other)
{
  std::swap(cond_, other.cond_);
  std::swap(listcmd_, other.listcmd_);

}

While::~While()
{
  delete(cond_);
  delete(listcmd_);

}

void While::accept(Visitor *v)
{
  v->visitWhile(this);
}

While *While::clone() const
{
  return new While(*this);
}



/********************   For    ********************/
For::For(ASSIGMENT *p1, COND *p2, INCREMENT *p3, ListCMD *p4)
{
  assigment_ = p1;
  cond_ = p2;
  increment_ = p3;
  listcmd_ = p4;

}

For::For(const For & other)
{
  assigment_ = other.assigment_->clone();
  cond_ = other.cond_->clone();
  increment_ = other.increment_->clone();
  listcmd_ = other.listcmd_->clone();

}

For &For::operator=(const For & other)
{
  For tmp(other);
  swap(tmp);
  return *this;
}

void For::swap(For & other)
{
  std::swap(assigment_, other.assigment_);
  std::swap(cond_, other.cond_);
  std::swap(increment_, other.increment_);
  std::swap(listcmd_, other.listcmd_);

}

For::~For()
{
  delete(assigment_);
  delete(cond_);
  delete(increment_);
  delete(listcmd_);

}

void For::accept(Visitor *v)
{
  v->visitFor(this);
}

For *For::clone() const
{
  return new For(*this);
}



/********************   Goto    ********************/
Goto::Goto(Ident p1)
{
  ident_ = p1;

}

Goto::Goto(const Goto & other)
{
  ident_ = other.ident_;

}

Goto &Goto::operator=(const Goto & other)
{
  Goto tmp(other);
  swap(tmp);
  return *this;
}

void Goto::swap(Goto & other)
{
  std::swap(ident_, other.ident_);

}

Goto::~Goto()
{

}

void Goto::accept(Visitor *v)
{
  v->visitGoto(this);
}

Goto *Goto::clone() const
{
  return new Goto(*this);
}



/********************   Assigment    ********************/
Assigment::Assigment(Ident p1, VALUE *p2)
{
  ident_ = p1;
  value_ = p2;

}

Assigment::Assigment(const Assigment & other)
{
  ident_ = other.ident_;
  value_ = other.value_->clone();

}

Assigment &Assigment::operator=(const Assigment & other)
{
  Assigment tmp(other);
  swap(tmp);
  return *this;
}

void Assigment::swap(Assigment & other)
{
  std::swap(ident_, other.ident_);
  std::swap(value_, other.value_);

}

Assigment::~Assigment()
{
  delete(value_);

}

void Assigment::accept(Visitor *v)
{
  v->visitAssigment(this);
}

Assigment *Assigment::clone() const
{
  return new Assigment(*this);
}



/********************   AssigmentV    ********************/
AssigmentV::AssigmentV(Ident p1, Integer p2, VALUE *p3)
{
  ident_ = p1;
  integer_ = p2;
  value_ = p3;

}

AssigmentV::AssigmentV(const AssigmentV & other)
{
  ident_ = other.ident_;
  integer_ = other.integer_;
  value_ = other.value_->clone();

}

AssigmentV &AssigmentV::operator=(const AssigmentV & other)
{
  AssigmentV tmp(other);
  swap(tmp);
  return *this;
}

void AssigmentV::swap(AssigmentV & other)
{
  std::swap(ident_, other.ident_);
  std::swap(integer_, other.integer_);
  std::swap(value_, other.value_);

}

AssigmentV::~AssigmentV()
{
  delete(value_);

}

void AssigmentV::accept(Visitor *v)
{
  v->visitAssigmentV(this);
}

AssigmentV *AssigmentV::clone() const
{
  return new AssigmentV(*this);
}



/********************   Increment    ********************/
Increment::Increment(Ident p1, VALUE *p2)
{
  ident_ = p1;
  value_ = p2;

}

Increment::Increment(const Increment & other)
{
  ident_ = other.ident_;
  value_ = other.value_->clone();

}

Increment &Increment::operator=(const Increment & other)
{
  Increment tmp(other);
  swap(tmp);
  return *this;
}

void Increment::swap(Increment & other)
{
  std::swap(ident_, other.ident_);
  std::swap(value_, other.value_);

}

Increment::~Increment()
{
  delete(value_);

}

void Increment::accept(Visitor *v)
{
  v->visitIncrement(this);
}

Increment *Increment::clone() const
{
  return new Increment(*this);
}



/********************   IncrementV    ********************/
IncrementV::IncrementV()
{

}

IncrementV::IncrementV(const IncrementV & other)
{

}

IncrementV &IncrementV::operator=(const IncrementV & other)
{
  IncrementV tmp(other);
  swap(tmp);
  return *this;
}

void IncrementV::swap(IncrementV & other)
{

}

IncrementV::~IncrementV()
{

}

void IncrementV::accept(Visitor *v)
{
  v->visitIncrementV(this);
}

IncrementV *IncrementV::clone() const
{
  return new IncrementV(*this);
}



/********************   Cond    ********************/
Cond::Cond(LOGICEXP *p1, ListLOGICEXP *p2)
{
  logicexp_ = p1;
  listlogicexp_ = p2;

}

Cond::Cond(const Cond & other)
{
  logicexp_ = other.logicexp_->clone();
  listlogicexp_ = other.listlogicexp_->clone();

}

Cond &Cond::operator=(const Cond & other)
{
  Cond tmp(other);
  swap(tmp);
  return *this;
}

void Cond::swap(Cond & other)
{
  std::swap(logicexp_, other.logicexp_);
  std::swap(listlogicexp_, other.listlogicexp_);

}

Cond::~Cond()
{
  delete(logicexp_);
  delete(listlogicexp_);

}

void Cond::accept(Visitor *v)
{
  v->visitCond(this);
}

Cond *Cond::clone() const
{
  return new Cond(*this);
}



/********************   LOGICOP1    ********************/
LOGICOP1::LOGICOP1()
{

}

LOGICOP1::LOGICOP1(const LOGICOP1 & other)
{

}

LOGICOP1 &LOGICOP1::operator=(const LOGICOP1 & other)
{
  LOGICOP1 tmp(other);
  swap(tmp);
  return *this;
}

void LOGICOP1::swap(LOGICOP1 & other)
{

}

LOGICOP1::~LOGICOP1()
{

}

void LOGICOP1::accept(Visitor *v)
{
  v->visitLOGICOP1(this);
}

LOGICOP1 *LOGICOP1::clone() const
{
  return new LOGICOP1(*this);
}



/********************   LOGICOP2    ********************/
LOGICOP2::LOGICOP2()
{

}

LOGICOP2::LOGICOP2(const LOGICOP2 & other)
{

}

LOGICOP2 &LOGICOP2::operator=(const LOGICOP2 & other)
{
  LOGICOP2 tmp(other);
  swap(tmp);
  return *this;
}

void LOGICOP2::swap(LOGICOP2 & other)
{

}

LOGICOP2::~LOGICOP2()
{

}

void LOGICOP2::accept(Visitor *v)
{
  v->visitLOGICOP2(this);
}

LOGICOP2 *LOGICOP2::clone() const
{
  return new LOGICOP2(*this);
}



/********************   LOGICOP3    ********************/
LOGICOP3::LOGICOP3()
{

}

LOGICOP3::LOGICOP3(const LOGICOP3 & other)
{

}

LOGICOP3 &LOGICOP3::operator=(const LOGICOP3 & other)
{
  LOGICOP3 tmp(other);
  swap(tmp);
  return *this;
}

void LOGICOP3::swap(LOGICOP3 & other)
{

}

LOGICOP3::~LOGICOP3()
{

}

void LOGICOP3::accept(Visitor *v)
{
  v->visitLOGICOP3(this);
}

LOGICOP3 *LOGICOP3::clone() const
{
  return new LOGICOP3(*this);
}



/********************   LOGICOP4    ********************/
LOGICOP4::LOGICOP4()
{

}

LOGICOP4::LOGICOP4(const LOGICOP4 & other)
{

}

LOGICOP4 &LOGICOP4::operator=(const LOGICOP4 & other)
{
  LOGICOP4 tmp(other);
  swap(tmp);
  return *this;
}

void LOGICOP4::swap(LOGICOP4 & other)
{

}

LOGICOP4::~LOGICOP4()
{

}

void LOGICOP4::accept(Visitor *v)
{
  v->visitLOGICOP4(this);
}

LOGICOP4 *LOGICOP4::clone() const
{
  return new LOGICOP4(*this);
}



/********************   LOGICOP5    ********************/
LOGICOP5::LOGICOP5()
{

}

LOGICOP5::LOGICOP5(const LOGICOP5 & other)
{

}

LOGICOP5 &LOGICOP5::operator=(const LOGICOP5 & other)
{
  LOGICOP5 tmp(other);
  swap(tmp);
  return *this;
}

void LOGICOP5::swap(LOGICOP5 & other)
{

}

LOGICOP5::~LOGICOP5()
{

}

void LOGICOP5::accept(Visitor *v)
{
  v->visitLOGICOP5(this);
}

LOGICOP5 *LOGICOP5::clone() const
{
  return new LOGICOP5(*this);
}



/********************   LOGICOP6    ********************/
LOGICOP6::LOGICOP6()
{

}

LOGICOP6::LOGICOP6(const LOGICOP6 & other)
{

}

LOGICOP6 &LOGICOP6::operator=(const LOGICOP6 & other)
{
  LOGICOP6 tmp(other);
  swap(tmp);
  return *this;
}

void LOGICOP6::swap(LOGICOP6 & other)
{

}

LOGICOP6::~LOGICOP6()
{

}

void LOGICOP6::accept(Visitor *v)
{
  v->visitLOGICOP6(this);
}

LOGICOP6 *LOGICOP6::clone() const
{
  return new LOGICOP6(*this);
}



/********************   LOGICOP7    ********************/
LOGICOP7::LOGICOP7()
{

}

LOGICOP7::LOGICOP7(const LOGICOP7 & other)
{

}

LOGICOP7 &LOGICOP7::operator=(const LOGICOP7 & other)
{
  LOGICOP7 tmp(other);
  swap(tmp);
  return *this;
}

void LOGICOP7::swap(LOGICOP7 & other)
{

}

LOGICOP7::~LOGICOP7()
{

}

void LOGICOP7::accept(Visitor *v)
{
  v->visitLOGICOP7(this);
}

LOGICOP7 *LOGICOP7::clone() const
{
  return new LOGICOP7(*this);
}



/********************   LOGICOP8    ********************/
LOGICOP8::LOGICOP8()
{

}

LOGICOP8::LOGICOP8(const LOGICOP8 & other)
{

}

LOGICOP8 &LOGICOP8::operator=(const LOGICOP8 & other)
{
  LOGICOP8 tmp(other);
  swap(tmp);
  return *this;
}

void LOGICOP8::swap(LOGICOP8 & other)
{

}

LOGICOP8::~LOGICOP8()
{

}

void LOGICOP8::accept(Visitor *v)
{
  v->visitLOGICOP8(this);
}

LOGICOP8 *LOGICOP8::clone() const
{
  return new LOGICOP8(*this);
}



/********************   LogicExp    ********************/
LogicExp::LogicExp(VALUE *p1, LOGICOP *p2, VALUE *p3)
{
  value_1 = p1;
  logicop_ = p2;
  value_2 = p3;

}

LogicExp::LogicExp(const LogicExp & other)
{
  value_1 = other.value_1->clone();
  logicop_ = other.logicop_->clone();
  value_2 = other.value_2->clone();

}

LogicExp &LogicExp::operator=(const LogicExp & other)
{
  LogicExp tmp(other);
  swap(tmp);
  return *this;
}

void LogicExp::swap(LogicExp & other)
{
  std::swap(value_1, other.value_1);
  std::swap(logicop_, other.logicop_);
  std::swap(value_2, other.value_2);

}

LogicExp::~LogicExp()
{
  delete(value_1);
  delete(logicop_);
  delete(value_2);

}

void LogicExp::accept(Visitor *v)
{
  v->visitLogicExp(this);
}

LogicExp *LogicExp::clone() const
{
  return new LogicExp(*this);
}



/********************   Exp    ********************/
Exp::Exp(ARITEXP *p1, ListARITEXP *p2)
{
  aritexp_ = p1;
  listaritexp_ = p2;

}

Exp::Exp(const Exp & other)
{
  aritexp_ = other.aritexp_->clone();
  listaritexp_ = other.listaritexp_->clone();

}

Exp &Exp::operator=(const Exp & other)
{
  Exp tmp(other);
  swap(tmp);
  return *this;
}

void Exp::swap(Exp & other)
{
  std::swap(aritexp_, other.aritexp_);
  std::swap(listaritexp_, other.listaritexp_);

}

Exp::~Exp()
{
  delete(aritexp_);
  delete(listaritexp_);

}

void Exp::accept(Visitor *v)
{
  v->visitExp(this);
}

Exp *Exp::clone() const
{
  return new Exp(*this);
}



/********************   ARITOP1    ********************/
ARITOP1::ARITOP1()
{

}

ARITOP1::ARITOP1(const ARITOP1 & other)
{

}

ARITOP1 &ARITOP1::operator=(const ARITOP1 & other)
{
  ARITOP1 tmp(other);
  swap(tmp);
  return *this;
}

void ARITOP1::swap(ARITOP1 & other)
{

}

ARITOP1::~ARITOP1()
{

}

void ARITOP1::accept(Visitor *v)
{
  v->visitARITOP1(this);
}

ARITOP1 *ARITOP1::clone() const
{
  return new ARITOP1(*this);
}



/********************   ARITOP2    ********************/
ARITOP2::ARITOP2()
{

}

ARITOP2::ARITOP2(const ARITOP2 & other)
{

}

ARITOP2 &ARITOP2::operator=(const ARITOP2 & other)
{
  ARITOP2 tmp(other);
  swap(tmp);
  return *this;
}

void ARITOP2::swap(ARITOP2 & other)
{

}

ARITOP2::~ARITOP2()
{

}

void ARITOP2::accept(Visitor *v)
{
  v->visitARITOP2(this);
}

ARITOP2 *ARITOP2::clone() const
{
  return new ARITOP2(*this);
}



/********************   ARITOP3    ********************/
ARITOP3::ARITOP3()
{

}

ARITOP3::ARITOP3(const ARITOP3 & other)
{

}

ARITOP3 &ARITOP3::operator=(const ARITOP3 & other)
{
  ARITOP3 tmp(other);
  swap(tmp);
  return *this;
}

void ARITOP3::swap(ARITOP3 & other)
{

}

ARITOP3::~ARITOP3()
{

}

void ARITOP3::accept(Visitor *v)
{
  v->visitARITOP3(this);
}

ARITOP3 *ARITOP3::clone() const
{
  return new ARITOP3(*this);
}



/********************   ARITOP4    ********************/
ARITOP4::ARITOP4()
{

}

ARITOP4::ARITOP4(const ARITOP4 & other)
{

}

ARITOP4 &ARITOP4::operator=(const ARITOP4 & other)
{
  ARITOP4 tmp(other);
  swap(tmp);
  return *this;
}

void ARITOP4::swap(ARITOP4 & other)
{

}

ARITOP4::~ARITOP4()
{

}

void ARITOP4::accept(Visitor *v)
{
  v->visitARITOP4(this);
}

ARITOP4 *ARITOP4::clone() const
{
  return new ARITOP4(*this);
}



/********************   AritExp    ********************/
AritExp::AritExp(VALUE *p1, ARITOP *p2, VALUE *p3)
{
  value_1 = p1;
  aritop_ = p2;
  value_2 = p3;

}

AritExp::AritExp(const AritExp & other)
{
  value_1 = other.value_1->clone();
  aritop_ = other.aritop_->clone();
  value_2 = other.value_2->clone();

}

AritExp &AritExp::operator=(const AritExp & other)
{
  AritExp tmp(other);
  swap(tmp);
  return *this;
}

void AritExp::swap(AritExp & other)
{
  std::swap(value_1, other.value_1);
  std::swap(aritop_, other.aritop_);
  std::swap(value_2, other.value_2);

}

AritExp::~AritExp()
{
  delete(value_1);
  delete(aritop_);
  delete(value_2);

}

void AritExp::accept(Visitor *v)
{
  v->visitAritExp(this);
}

AritExp *AritExp::clone() const
{
  return new AritExp(*this);
}




/********************   ListVAR    ********************/

void ListVAR::accept(Visitor *v)
{
  v->visitListVAR(this);
}

ListVAR *ListVAR::clone() const
{
  return new ListVAR(*this);
}

ListVAR* consListVAR(VAR* x, ListVAR* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAST    ********************/

void ListAST::accept(Visitor *v)
{
  v->visitListAST(this);
}

ListAST *ListAST::clone() const
{
  return new ListAST(*this);
}

ListAST* consListAST(AST* x, ListAST* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListCONST    ********************/

void ListCONST::accept(Visitor *v)
{
  v->visitListCONST(this);
}

ListCONST *ListCONST::clone() const
{
  return new ListCONST(*this);
}

ListCONST* consListCONST(CONST* x, ListCONST* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListFUNCTION    ********************/

void ListFUNCTION::accept(Visitor *v)
{
  v->visitListFUNCTION(this);
}

ListFUNCTION *ListFUNCTION::clone() const
{
  return new ListFUNCTION(*this);
}

ListFUNCTION* consListFUNCTION(FUNCTION* x, ListFUNCTION* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListPARAM    ********************/

void ListPARAM::accept(Visitor *v)
{
  v->visitListPARAM(this);
}

ListPARAM *ListPARAM::clone() const
{
  return new ListPARAM(*this);
}

ListPARAM* consListPARAM(PARAM* x, ListPARAM* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListCMD    ********************/

void ListCMD::accept(Visitor *v)
{
  v->visitListCMD(this);
}

ListCMD *ListCMD::clone() const
{
  return new ListCMD(*this);
}

ListCMD* consListCMD(CMD* x, ListCMD* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLOGICEXP    ********************/

void ListLOGICEXP::accept(Visitor *v)
{
  v->visitListLOGICEXP(this);
}

ListLOGICEXP *ListLOGICEXP::clone() const
{
  return new ListLOGICEXP(*this);
}

ListLOGICEXP* consListLOGICEXP(LOGICEXP* x, ListLOGICEXP* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListARITEXP    ********************/

void ListARITEXP::accept(Visitor *v)
{
  v->visitListARITEXP(this);
}

ListARITEXP *ListARITEXP::clone() const
{
  return new ListARITEXP(*this);
}

ListARITEXP* consListARITEXP(ARITEXP* x, ListARITEXP* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}





